AKKA:
******
Chapter1:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
An actor is a container for State, Behavior, a Mailbox, Children and a Supervisor Strategy. 
All of this is encapsulated behind an Actor Reference.

#1 Supervision:
------------------------
#1.1
 An actor system will during its creation start at least three actors
	/user: - parent of all user created actors. Can be configured via SystemConfigurator.
	/system:- controls logging during the orderly shutdown of /user: actors, though logging itself is implemented by /user: actors
	/root: - no parent, bubble-walker, SupervisorStrategy.stoppingStrategy to recursively stop all children.

#1.2
Supervisor has following options on event of a failure:
	•  Resume the subordinate, keeping its accumulated internal state
	•  Restart the subordinate, clearing out its accumulated internal state
	•  Terminate the subordinate permanently
	•  Escalate the failure, thereby failing itself
#1.3
Actor restart happens for failures like:
	• Systematic (i.e. programming) error for the specific message received
	• (Transient) failure of some external resource used during processing the message
	• Corrupt internal state of the actor
New instance of the underlying Actor class and replacing the failed instance with the fresh one inside the child’s ActorRef; the ability to do this is one of the reasons for
encapsulating actors within special references. The new actor then resumes processing its mailbox, meaning that the restart is not visible outside of the actor itself with the notable exception that the message during which the failure occurred is not re-processed.
The precise sequence of events during a restart is the following: 
	1. suspend the actor (which means that it will not process normal messages until resumed), and recursively suspend all children
	2. call the old instance’s preRestart hook (defaults to sending termination requests to all children and calling postStop)
	3. wait for all children which were requested to terminate (using context.stop()) during preRestart to actually terminate; this—
	    like all actor operations—is non-blocking, the termination notice from the last killed child will effect the progression to the next step
	4. create new actor instance by invoking the originally provided factory again
	5. invoke postRestart on the new instance (which by default also calls preStart)
	6. send restart request to all children which were not killed in step 3; restarted children will follow the same process recursively, from step 2
	7.resume the actor
#1.4 
Lifecycle Monitoring:
	Any actor can monitor the other for this deathWatch using ActorContext.watch(targetActorRef), ActorContext.unwatch(targetActorRef).
	message will be delivered irrespective of the order in which the monitoring request and target’s termination occur.
#1.5
Supervision strategies:
	OneForOneStrategy => only to the failed child
	AllForOneStrategy => only to the failed child plus siblings
#1.6
Actor reference:
An actor reference is a subtype of ActorRef, whose foremost purpose is to support sending messages to the actor it represents. Each actor has access to its canonical (local) reference through the 'self' field; this reference is also included as 'sender' reference by default for all messages sent to other actor.
Types of actors:
	Purely local actor references without remoting, used for talking in the same jvm
	Local actor references with remoting, used as gateways into their jvm, local mirror to remote on the opposite side 
	Remote actor references point to actors in other JVM with message serialisation
	Router references, will just send the message to their children without any processing from their side.
	Local Special:
		PromiseActorRef is the special representation of a Promise for the purpose of being completed by the response from an actor. akka.pattern.ask creates this actor reference.
		DeadLetterActorRef is the default implementation of the dead letters service to which Akka routes all messages whose destinations are shut down or non-existent.
		EmptyLocalActorRef is what Akka returns when looking up a non-existent local actor path:
#1.7
Actor Path: consists of an anchor, which identifies the actor system, followed by the concatenation of the path elements, from root guardian to the designated actor; the path elements are the names of the traversed actors and are separated by slashes.
	"akka://my-sys/user/service-a/worker1" // purely local
	"akka.tcp://my-sys@host.example.com:5678/user/service-b" // remote
	"cluster://my-cluster/service-c" // clustered (Future Extension)
akka.tcp is the default remote transport for the 2.2 release; other transports are pluggable
	Logical path: From each parent to child, a complete ancestry path
	Physical path: Parent and child can exist in different jvms, so the path is actually wiring up network jumping info. 
				  However, a child can be directly accessed instead of going via parent to avoid needless routing
	Virtual path: WIP, moving clusters as a whole from system to another since everything is virtual.







	

	




	
 


	









