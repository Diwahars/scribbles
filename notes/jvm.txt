JVM Notes
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
INTRODUCTION
**************
1) 	Java architecture arises out of four distinct but interrelated technologies:
		the Java programming language
		the Java class file format
		the Java Application Programming Interface
		the Java virtual machine
2) 	JVM supports all three prongs of Java network-oriented architecture: 'platform independence, security, and network-mobility'.
3) 	JVM has a 'Classloader' (to load the byte from classes) and an 'Execution Engine'(to execute the bytecode)
4) 	Execution Engine offers many implementations
		Simple Interpretation -> one at a time
		Just In Time Compilation -> bytecode to native machine code just before execution of a method, then saved to future use.
		Adaptive Optimiser -> compile to native code only the heavily used portion of the code.
		Direct Native -> JVM built on top of a chip that executes Java bytecodes natively, the execution engine is actually embedded in the chip.
5) 	In Java, there are two kinds of methods: Java and native. 
	A 'Java method' is written in the Java language, compiled to bytecodes, and stored in class files.
	A 'native method' is written in some other language, such as C, C++, or assembly, and compiled to the native machine code of a particular processor. 
	'Native methods' are stored in a dynamically linked library whose exact form is platform specific. While 'Java methods' are platform independent, native methods are not. 
	When a running Java program calls a native method, the virtual machine loads the dynamic library that contains the native method and invokes it.
	Use of 'Native methods' can make your program platform-specific, can be alleviated using 'JNI', but vendors are mandated to implement it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS LOADER
*************
2 types are 
	'Bootstrap' -> implemented inside JVM in native code
	'user-defined' -> written by coders in Java
Boundaries exist between classes loaded by different class loaders, only the JVM can co-relate.
CLASS
******
Provides platform-independence and network-mobility, by enabling a common form to be ported to JVMs hosted on different platform

JAVA API
********
API is implemented for different platforms
Consistent primitives across platforms -> Int is always 4byte 
Provides security by using 'Security manager' (1.2) or 'Access Controllers' (1.3+). Any malicious calls are intersected at stack levels by security.
Your program -> Java API -> Native library -> Host OS 

JAVA LANGUAGE
*************
OOP, Garbage Collection, no direct memory handling, only references

ARCHITECTURAL TRADEOFFS
************************
Performance still being worked to be on par with C/C++
Differs for every JVM implementation
Adaptive Optimiser can do only static linking 
Unpredictable Garbage collection and Threads
Dynamic linking of classes is all symbolic links, thereby making it easier to decompile back to source. This makes your code open to competitors
	Can be alleviated by using obfuscation.
	
	'Static linking' is the result of the linker copying all library routines used in the program into the executable image. 
	This may require more disk space and memory than dynamic linking, but is both faster and more portable, 
	since it does not require the presence of the library on the system where it is run.
	
	'Dynamic linking' is accomplished by placing the name of a sharable library in the executable image. 
	Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. 
	An advantage of dynamic linking is that multiple programs can share a single copy of the library.	
#--------------------------------------------------------------------------------------------------------------------------------------------	
PLATFORM INDEPEDENCE:
*********************
Consistent primitives across platforms -> Int is always 4byte 
Sun initially started Java for embedded systems only has desktops were dominated by MS and Apple
J2ME, J2SE, J2EE

SECURITY
*********
The fundamental components responsible for Java's sandbox are:
	the class loader architecture
	the class file verifier
	safety features built into the Java virtual machine (and the language)
	the security manager and the Java API