JVM Notes
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CHAPTER1: INTRODUCTION
**********************
1.1| 	Java architecture arises out of four distinct but interrelated technologies:
			the Java programming language
			the Java class file format
			the Java Application Programming Interface
			the Java virtual machine
1.2| 	JVM supports all three prongs of Java network-oriented architecture: 'platform independence, security, and network-mobility'.
1.3| 	JVM has a 'Classloader' (to load the byte from classes) and an 'Execution Engine'(to execute the bytecode)
1.4| 	Execution Engine offers many implementations
		Simple Interpretation -> one at a time
		Just In Time Compilation -> bytecode to native machine code just before execution of a method, then saved to future use.
		Adaptive Optimiser -> compile to native code only the heavily used portion of the code.
		Direct Native -> JVM built on top of a chip that executes Java bytecodes natively, the execution engine is actually embedded in the chip.
1.5| 	In Java, there are two kinds of methods: Java and native. 
	A 'Java method' is written in the Java language, compiled to bytecodes, and stored in class files.
	A 'native method' is written in some other language, such as C, C++, or assembly, and compiled to the native machine code of a particular processor. 
	'Native methods' are stored in a dynamically linked library whose exact form is platform specific. While 'Java methods' are platform independent, native methods are not. 
	When a running Java program calls a native method, the virtual machine loads the dynamic library that contains the native method and invokes it.
	Use of 'Native methods' can make your program platform-specific, can be alleviated using 'JNI', but vendors are mandated to implement it.
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS LOADER
*************
2 types are 
	'Bootstrap' -> implemented inside JVM in native code
	'user-defined' -> written by coders in Java
Boundaries exist between classes loaded by different class loaders, only the JVM can co-relate.
CLASS
******
Provides platform-independence and network-mobility, by enabling a common form to be ported to JVMs hosted on different platform

JAVA API
********
API is implemented for different platforms
Consistent primitives across platforms -> Int is always 4byte 
Provides security by using 'Security manager' (1.2) or 'Access Controllers' (1.3+). Any malicious calls are intersected at stack levels by security.
Your program -> Java API -> Native library -> Host OS 

JAVA LANGUAGE
*************
OOP, Garbage Collection, no direct memory handling, only references

ARCHITECTURAL TRADEOFFS
************************
Performance still being worked to be on par with C/C++
Differs for every JVM implementation
Adaptive Optimiser can do only static linking 
Unpredictable Garbage collection and Threads
Dynamic linking of classes is all symbolic links, thereby making it easier to decompile back to source. This makes your code open to competitors
	Can be alleviated by using obfuscation.
	
	'Static linking' is the result of the linker copying all library routines used in the program into the executable image. 
	This may require more disk space and memory than dynamic linking, but is both faster and more portable, 
	since it does not require the presence of the library on the system where it is run.
	
	'Dynamic linking' is accomplished by placing the name of a sharable library in the executable image. 
	Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. 
	An advantage of dynamic linking is that multiple programs can share a single copy of the library.	
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER2: PLATFORM INDEPEDENCE:
****************************************
Consistent primitives across platforms -> Int is always 4byte 
Sun initially started Java for embedded systems only has desktops were dominated by MS and Apple
J2ME, J2SE, J2EE
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER3: SECURITY
***************************
Javas security model is focused on protecting end-users from hostile programs downloaded across a network from untrusted sources. 
To accomplish this goal, Java provides a customizable "sandbox" in which Java programs run. A Java program must play only inside its sandbox. 
It can do anything within the boundaries of its sandbox, but can't take any action outside those boundaries. 
The sandbox for untrusted Java applets, for example, prohibits many activities, including:

    reading or writing to the local disk,
    making a network connection to any but the host from which the applet came,
    creating a new process, and
    loading a new dynamic library and directly calling a native method.
    
The fundamental components responsible for Java's sandbox are:
	the class loader architecture
	the class file verifier
	safety features built into the Java virtual machine (and the language)
	the security manager and the Java API

3.1| 'CLASS LOADER'
--------------------------------------------
Each call to load a class, is made first to the primordial class loader(Boot), if it does not find in its trusted store, then trickle down to custom loaders.

Rules to write a custom class loader
	0	Make sure your class loader prevents loading any class that impersonates like 'java.lang' apis
	1	If packages exist that this class loader is not allowed to load from, the class loader checks whether the requested class is in one of those 
		forbidden packages. If so, it throws a security exception. Else, it continues on to step two. 
	2	The class loader passes the request to the primordial class loader. If the primordial class loader successfully returns the class, 
		the class loader returns that same class. Else, it continues on to step three. 
	3	If trusted packages exist that this class loader is not allowed to add classes to, 
		the class loader checks whether the requested class is in one of those restricted packages. 
		If so, it throws a security exception. Else, it continues on to step four. 
	4	Finally, the class loader attempts to load the class in the custom way, such as by downloading it across a network. 
		If successful, it returns the class. Else, it throws a "no class definition found" error.
		
3.2| 'CLASS FILE VERIFIER'
--------------------------------------------------
Working in conjunction with the class loader, the class file verifier ensures that loaded class files have a proper internal structure. 
If the class file verifier discovers a problem with a class file, it throws an exception
Two steps:
	After classloading, verifies the integrity of the bytecodes it import
	During execution, confirms the existence of symbolically referenced classes, fields, and methods. 
	
3.2.1| Step1: Internal Checks:
--------------------------------------------------------
	Phase one of the class file verifier makes sure the imported class file is properly formed, internally consistent, adheres to the constraints of the Java programming language, and contains bytecodes that will be safe for the Java Virtual Machine to execute. 
	If the class file verifier finds that any of these are not true, it throws an error, and the class file is never used by the program.
	Checks if bytecodes neither truncated nor enhanced with extra trailing bytes. 
	Checks if method descriptor have a context free grammar
	
	The bytecode streams that represent Java methods are a series of one-byte instructions, called opcodes, each of which may be followed by one or more operands. 
	The operands supply extra data needed by the Java Virtual Machine to execute the opcode instruction. 
	The activity of executing bytecodes, one opcode after another, constitutes a thread of execution inside the Java Virtual Machine. 
	Each thread is awarded its own Java Stack, which is made up of discrete frames. 
	Each method invocation gets its own frame, a section of memory where it stores, among other things, local variables and intermediate results of computation. 
	The part of the frame in which a method stores intermediate results is called the method's  operand stack. 
	An opcode and its (optional) operands may refer to the data stored on the operand stack or in the local variables of the method's frame. 
	Thus, the virtual machine may use data on the operand stack, in the local variables, or both, in addition to any data stored as operands following an opcode when it executes the opcode.
	
3.2.2| STEP2: Verfication of symbolic references	
------------------------------------------------------------------------------------------------
Dynamic linking is the process of resolving symbolic references into direct references.
As the JVM executes bytecodes and encounters an opcode that, for the first time, uses a symbolic reference to another class, the virtual machine must resolve the symbolic reference. 
The virtual machine performs two basic tasks during resolution:
    a) find the class being referenced (loading it if necessary)
    b) replace the symbolic reference with a direct reference, such as a pointer or offset, to the class, field, or method
Throws ClassNotFoundException, MethodNotFoundException for cases when they could not have been detected during compile time.
Also does the following, though the language compiler has already done it
    a) type-safe reference casting
    b) structured memory access (no pointer arithmetic)
    c) automatic garbage collection (can't explicitly free allocated memory)
    d) array bounds checking
    e) checking references for null

3.3| Memory access
--------------------------------
The runtime data areas are the memory areas in which the Java Virtual Machine stores the data it needs to execute a Java application: 
	Java stacks (one for each thread), 
	a method area, where bytecodes are stored, and 
	a garbage-collected heap, where the objects created by the running program are stored. 
If you peer into a class file, you wonít find any memory addresses, every address is decided at runtime by JVM.
The prohibition on unstructured memory access is a solid barrier against the malicious manipulation of memory. 
Native methods are still points of weakness as they dont fall under Java Security Sandbox

3.4| Exceptions 
--------------------------------
One final mechanism that is built into the Java Virtual Machine that contributes to security is structured error handling with exceptions. Because of its support for exceptions,  JVM has something structured to do when a security violation occurs. Instead of crashing, the Java Virtual Machine can throw an exception or an error, which may result in the death of the offending thread, but shouldn't crash the system. Throwing an error (as opposed to throwing an exception) almost always results in the death of the thread in which the error was thrown.

3.5|
Security Manager
----------------------
By using class loaders, you can prevent code loaded by different class loaders from interfering with one another inside the JVM, but to protect assets external to JVM, you must use a security manager customisable via security.policy.

The classes of the Java API check with the security manager before they:

    accept a socket connection from a specified host and port number
    modify a thread (change its priority, stop it, etcÖ)
    open a socket connection to a specified host and port number
    create a new class loader
    delete a specified file
    create a new process
    cause the application to exit
    load a dynamic library that contains native methods
    wait for a connection on a specified local port number
    load a class from a specified package (used by class loaders)
    add a new class to a specified package (used by class loaders)
    access or modify system properties
    access a specified system property
    read from a specified file
    write to a specified file

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER4: NETWORK MOBILITY:
**********************************
Dynamic linking - all symbolic references only, no inlining of called code.
Dynamic extensions - URLCLassloaders 
Compaction - jar files.

The main way Java's architecture facilitates network-mobility directly is by breaking up the monolithic binary executable into compact class files, which can be loaded as needed.
Bytecode streams they contain are designed to be compact. They are called "bytecodes" because each instruction occupies only one byte
The JAR file is to group classes to consolidate TCP handshake times of mutiple classes.

Applets made JAVA future, as Sun released it along with Netscape.
Java applets can run on any platform so long as there is a Java-capable browser for that platform. Java applets also demonstrated Javaís security capabilities, because they run inside a strict sandbox. But most significantly, Java applets demonstrated the promise of network-mobility.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER 5: JVM:
*******************
when you say "Java Virtual Machine." You may be speaking of:
    the abstract specification,
    a concrete implementation, or
    a runtime instance.
The base architecture of JVM comprises of 
	Class loader system
	Execution Engine
	Runtime data areas
		Stack - local variables,method args, method returns of thread, made up of Frames (1 frame/1 method call)
		Heap - objects reside here
		Method Area - class structure data
		PC registers - Program Counter Registers 1/thread, hold the next instruction to execute
		Native method stacks
Data Types		
	Value Types  -  primitives (byte, char, short, int, long, float, double). boolean is implemented by a int (0,1).
	Reference types - objects (class, interface, collections)

JVM specifies only primitive ranges (for efg, int(8bits) -2^7 to +2^7-1) and not their actual sizes, its upto the implementers.

5.1| Class Loader: 
	Loading: finding and importing the binary data for a type
    Linking: performing verification, preparation, and (optionally) resolution
        a. Verification: ensuring the correctness of the imported type
        b. Preparation: allocating memory for class variables and initializing the memory to default values
        c. Resolution: transforming symbolic references from the type into direct references.
	Initialization: invoking Java code that initializes class variables to their proper starting values.
-------------------------------------------------------------------------------------------------------------------
5.2| Method Area
When JVM loads a type, it uses a class loader to locate the appropriate class file. The class loader reads in the class file--a linear stream of binary data--and passes it to the virtual machine. The virtual machine extracts information about the type from the binary data and stores the information in the method area. Memory for class (static) variables declared in the class is also taken from the method area.
Designers can choose whatever data structures and organization they feel optimize their implementations performance, in the context of its requirements.
All threads share the same method area, so access to the method areaís data structures must be designed to be thread-safe. If two threads are attempting to find a class named Lava, for example, and Lava has not yet been loaded, only one thread should be allowed to load it while the other one waits.
Expands and contracts, can also be garbage collected.
In addition to the basic type information listed above, the virtual machine must also store for each loaded type:

    a. The constant pool for the type
    b. Field information  (name, type, order inside type)
    c. Method information (name, params,return, order inside type)
    d. All class (static) variables declared in the type, except constants(final) which go to pool
    e. A reference to class ClassLoader
    f. A reference to class Class
    g. A method table is an array of direct references to all the instance methods that may be invoked on a class instance, including instance methods inherited from superclasses. 
-------------------------------------------------------------------------------------------------------------------
5.3| Heap
Objects and collections go here
Collected by Garbage Collector, design left to implementers
Need not be contiguous, expands and contracts as per need
Object representation--an integral aspect of the overall design of the heap and garbage collector--is a decision of implementation designers

#design possiblility #1
Divides the heap into two parts: A handle pool and an object pool. An object reference is a native pointer to a handle pool entry. 
A handle pool entry has two components: a pointer to instance data in the object pool and a pointer to class data in the method area
Disadvantage of using 2 pointers for an obj reference.

#design possiblility #2
Object reference points to a data aggregate in heap, which is a collection of pointers to instance data and one pointer to class data in method area.

#design possiblility #3
one pointer to instance data in heap and another to a method table in methods area. Methods table is not mandated by JVM Spec.

#design possiblility #4
each instance in heap can hold an copy of class image to boost performance, but it drains heaps space.

#lock
Each object has a lock for threads and a wait-set for storing threads waiting on it
Additional data can also be stored for garbage collection mechanisms. A mark and sweep algorithm, for instance, could potentially use a separate bitmap for marking referenced and unreferenced objects

#finaliser
Garbage collectors must run the finalizer of any object whose class declares one before it reclaims the memory occupied by that object. 
The specification states that a garbage collector will only execute an object's finalizer once, but allows that finalizer to "resurrect" the object: to make the object referenced again. 
When the object becomes unreferenced for a second time, the garbage collector must not finalize it again

Arrays, like classes, are stored in the heap.
 For example, 
 the class name for an array of ints is "[I". 
 The class name for a three-dimensional array of bytes is "[[[B",
 the class name for a two-dimensional array of Objects is "[[Ljava.lang.Object". 




