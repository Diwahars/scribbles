JVM Notes
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CHAPTER1: INTRODUCTION
**********************
1.1| 	Java architecture arises out of four distinct but interrelated technologies:
			the Java programming language
			the Java class file format
			the Java Application Programming Interface
			the Java virtual machine
1.2| 	JVM supports all three prongs of Java network-oriented architecture: 'platform independence, security, and network-mobility'.
1.3| 	JVM has a 'Classloader' (to load the byte from classes) and an 'Execution Engine'(to execute the bytecode)
1.4| 	Execution Engine offers many implementations
		Simple Interpretation -> one at a time
		Just In Time Compilation -> bytecode to native machine code just before execution of a method, then saved to future use.
		Adaptive Optimiser -> compile to native code only the heavily used portion of the code.
		Direct Native -> JVM built on top of a chip that executes Java bytecodes natively, the execution engine is actually embedded in the chip.
1.5| 	In Java, there are two kinds of methods: Java and native. 
	A 'Java method' is written in the Java language, compiled to bytecodes, and stored in class files.
	A 'native method' is written in some other language, such as C, C++, or assembly, and compiled to the native machine code of a particular processor. 
	'Native methods' are stored in a dynamically linked library whose exact form is platform specific. While 'Java methods' are platform independent, native methods are not. 
	When a running Java program calls a native method, the virtual machine loads the dynamic library that contains the native method and invokes it.
	Use of 'Native methods' can make your program platform-specific, can be alleviated using 'JNI', but vendors are mandated to implement it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS LOADER
*************
2 types are 
	'Bootstrap' -> implemented inside JVM in native code
	'user-defined' -> written by coders in Java
Boundaries exist between classes loaded by different class loaders, only the JVM can co-relate.
CLASS
******
Provides platform-independence and network-mobility, by enabling a common form to be ported to JVMs hosted on different platform

JAVA API
********
API is implemented for different platforms
Consistent primitives across platforms -> Int is always 4byte 
Provides security by using 'Security manager' (1.2) or 'Access Controllers' (1.3+). Any malicious calls are intersected at stack levels by security.
Your program -> Java API -> Native library -> Host OS 

JAVA LANGUAGE
*************
OOP, Garbage Collection, no direct memory handling, only references

ARCHITECTURAL TRADEOFFS
************************
Performance still being worked to be on par with C/C++
Differs for every JVM implementation
Adaptive Optimiser can do only static linking 
Unpredictable Garbage collection and Threads
Dynamic linking of classes is all symbolic links, thereby making it easier to decompile back to source. This makes your code open to competitors
	Can be alleviated by using obfuscation.
	
	'Static linking' is the result of the linker copying all library routines used in the program into the executable image. 
	This may require more disk space and memory than dynamic linking, but is both faster and more portable, 
	since it does not require the presence of the library on the system where it is run.
	
	'Dynamic linking' is accomplished by placing the name of a sharable library in the executable image. 
	Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. 
	An advantage of dynamic linking is that multiple programs can share a single copy of the library.	
#--------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER2: PLATFORM INDEPEDENCE:
********************************
Consistent primitives across platforms -> Int is always 4byte 
Sun initially started Java for embedded systems only has desktops were dominated by MS and Apple
J2ME, J2SE, J2EE
#--------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER3: SECURITY
*******************
The fundamental components responsible for Java's sandbox are:
	the class loader architecture
	the class file verifier
	safety features built into the Java virtual machine (and the language)
	the security manager and the Java API

3.1| 'CLASS lOADER'
Rules to write a custom class loader
	0	Make sure your class loader prevents loading any class that impersonates like 'java.lang' apis
	1	If packages exist that this class loader is not allowed to load from, the class loader checks whether the requested class is in one of those 
		forbidden packages. If so, it throws a security exception. Else, it continues on to step two. 
	2	The class loader passes the request to the primordial class loader. If the primordial class loader successfully returns the class, 
		the class loader returns that same class. Else, it continues on to step three. 
	3	If trusted packages exist that this class loader is not allowed to add classes to, 
		the class loader checks whether the requested class is in one of those restricted packages. 
		If so, it throws a security exception. Else, it continues on to step four. 
	4	Finally, the class loader attempts to load the class in the custom way, such as by downloading it across a network. 
		If successful, it returns the class. Else, it throws a "no class definition found" error.
3.2| 'CLASS FILE VERIFIER'

#--------------------------------------------------------------------------------------------------------------------------------------------	


