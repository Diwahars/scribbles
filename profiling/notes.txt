A:Tools
------------------------------------------------------------------------------------------------------
#1 free=>jvisualvm: 
    present in jdk along with java, javac
    much better than jconsole
    automatically monitors process that uses its parent jdk
    gives cpu, heap, ram monitoring
    can wire up with remote hosts and uses jmx/jstats
    can analyse thread dumps
#2 commercial=>yourkit, Jprofile

B:Do it yourself
------------------------------------------------------------------------------------------------------
CPU Profiling:
**************
#1 System.currentMilliSec() => for rarely called long running methods
#2 ConcurrentHashMap => for frequently called short running methods. Use the data to get averages.
#3 Sampling - Analyse threaddumps to get hotspots (bad performing code)
    3.1 kill -3 pid > dump.txt 
    3.2 jstack pid > dump.txt
    3.3 Thread.getAllStacktraces() -for programmatically getting all threads
Memory Profiling:
*****************
#1  jps => find pids of java processes
#2  jmap -histo <pid> => gives number of instances and memory consumed per class
    jmap -histo:live <pid> => does a garbage collection before counting instances, 10 sec pause, cannot be used in prod
    jmap -dump:<options> <pid> => gives thread dump
#3  JVM options
    -XX:+PrintClassHistogram => on 'kill -3' will call 'jmap -histo'
    -XX:+HeapDumpOnOutOfMemoryError => produces dump in hprof format
    CPU and thread profiling wont help in analysing big memory allocation issues.Only slow GC reflect the issue.    
    JVM flags: 
        verbose:gc, -XX:+PrintGC, +-XX:+PrintGCDetails => logs time spent on GC
        -Xaprof => pints memory allocation by class on process exit
        
#4  Use byte code manipulation with javassist to do more tracking
    runtime byte code manipulation can be done with javaagent

    



------------------------------------------------------------------------------------------------------

