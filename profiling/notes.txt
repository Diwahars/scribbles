A:Profiling Tools
------------------------------------------------------------------------------------------------------
1| free=>jvisualvm: 
    present in jdk along with java, javac
    much better than jconsole
    automatically monitors process that uses its parent jdk
    gives cpu, heap, ram monitoring
    can wire up with remote hosts and uses jmx/jstats
    can analyse thread dumps

2| commercial=> Yourkit, Jprofile

B:Do it yourself
------------------------------------------------------------------------------------------------------
CPU Profiling:
--------------*
1| System.currentMilliSec() => for rarely called long running methods

2| ConcurrentHashMap => for frequently called short running methods. Use the data to get averages.

3| Sampling - Analyse threaddumps to get hotspots (bad performing code)
    3.1 kill -3 pid > dump.txt 
    3.2 jstack pid > dump.txt
    3.3 Thread.getAllStacktraces() -for programmatically getting all threads

Memory Profiling:
------------------*
1|  jps => find pids of java processes

2|  jmap -histo <pid> => gives number of instances and memory consumed per class
    jmap -histo:live <pid> => does a garbage collection before counting instances, 10 sec pause, cannot be used in prod
    jmap -dump:<options> <pid> => gives thread dumps

3|  JVM options
    -XX:+PrintClassHistogram => on 'kill -3' will call 'jmap -histo'
    -XX:+HeapDumpOnOutOfMemoryError => produces dump in hprof format
    CPU and thread profiling wont help in analysing big memory allocation issues.Only slow GC reflect the issue.    
    JVM flags: 
    3.1| verbose:gc, -XX:+PrintGC, +-XX:+PrintGCDetails => logs time spent on GC
    3.2| -Xaprof => pints memory allocation by class on process exit

4|  Use byte code manipulation with javassist to do more tracking
    runtime byte code manipulation can be done with javaagent

------------------------------------------------------------------------------------------------------
C: Garbage Collection |mechanical sympathy
-------------------------------------------*
Generation GC (eden.survivor, tenured) algorithms may not be good when you create a lot of long-lived objs.

1| Throughput => The amount of work done by an application as a ratio of time spent in GC. 
   Target throughput with ‑XX:GCTimeRatio=99;99 is the default equating to 1% GC time.

2| Latency => The time taken by systems in responding to events which is impacted by pauses introduced by garbage collection. 
   Target latency for GC pauses with ‑XX:MaximumGCPauseMillis=<n>.

3| Memory => The amount of memory our systems use to store state, which is often copied and moved around when being managed. 
   The set of active objects retained by the application at any point in time is known as the Live Set. 
   Maximum heap size –Xmx<n> is a tuning parameter for setting the heap size available to an application.

4| Stop the world events => All threads must come to a safe point before GC can proceed.
   -XX:PrintGCApplicationStoppedTime will show this.

Heap Organisation:
------------------*
1| eden => the region of fresh objects
2| survivor => regions where objs that survived one eden collection.
3| tenured => long lived objs
4| perm => non-heap region for class, static strings, java 8 dumped it

TLAB:
-----*
Each thread is allocated a Thread Local Allocation Buffer.
They create objs by bumping up a pointer in this space
No contentions between threads, much faster than C malloc
But when large objs are created, the TLAB can be a limiter, so the new big obj is in the tenured generation.(-XX:PretenureSizeThreshold=<n>)

Minor Collection:
------------------*
Movement of objs from eden to survivor to tenured
Search through live objs using object graphs and also any back references from older generation to new generation(card table)
survivor space has 2 spaces (from-space, to-space)
    to-space => target region to store newly moved objs during collection
    from-space => stores objs from previous collection, also undergoes collection during minor stage.
cost of collection is tied more to number of instances than memory, but doubling eden space can help in reducing minor collection frequency.








