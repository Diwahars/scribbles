_________________________________________________________________________________________________________________________________________
Thread-based implementation:
The behavior of a concurrent process is defined by implementing a thread-specific method.
The execution state is maintained by an associated thread stack.
Threads support blocking operations such as system I/O, and can be executed on multiple processor cores in parallel.
_________________________________________________________________________________________________________________________________________
Event-based implementation:
The behavior is defined by a number of (non-nested) event handlers which are called from inside an event loop.
The execution state of a concurrent process is maintained by an associated record or object.
Event-based computation, on the other hand, is more lightweight and scales to large numbers of actors
An actor suspends when react fails to remove a matching message from the mailbox:
can get blocked and block other actors
_________________________________________________________________________________________________________________________________________
    class Task extends Runnable {
    def run() { ... }
    }
A task is generated in the following three cases:
1. Spawning a new actor using actor { body } generates a task that executes body.
2. Calling react where a message can be immediately removed from the mailbox generates a task that processes the message.
3. Sending a message to an actor suspended in a react that enables it to continue generates a task that processes the message
4. Pending tasks are kept in a task queue inside a global scheduler object.
5. Tasks are executed by Forked Workers

In unified model is to use a thread pool to execute actors, and to resize the thread pool whenever it is necessary to support general thread operations.
If actors use only operations of the event-based model, the size of the thread pool can be fixed.
This is different if some of the actors use blocking operations such as 'receive' or system I/O.
In the case where every worker thread is occupied by a suspended actor and there are pending tasks, the thread pool has to grow
In JVM, a approximation of monitoring time-stamp of the last “library activity” indicates “all worker threads blocked”.
-------------------------------------------------------------------------------

while-receive-actor
	(ForkJoinPool-1-worker-13,19999)
mailbox-size=0|execCount=19999|actor state=Blocked|active count=6

loop-receive-actor
	(ForkJoinPool-1-worker-1,3137)
	(ForkJoinPool-1-worker-5,2497)
	(ForkJoinPool-1-worker-15,2159)
	(ForkJoinPool-1-worker-9,1468)
	(ForkJoinPool-1-worker-11,1956)
	(ForkJoinPool-1-worker-7,2735)
	(ForkJoinPool-1-worker-13,2001)
	(ForkJoinPool-1-worker-3,4046)
mailbox-size=0|execCount=19999|actor state=Blocked|active count=11
--------------------------------------------------------------------------------
while-react-actor
	ForkJoinPool-1-worker-11,1)
mailbox-size=1|execCount=0|actor state=Terminated|active count=3

loop-react-actor
	(ForkJoinPool-1-worker-1,2370)
	(ForkJoinPool-1-worker-5,2261)
	(ForkJoinPool-1-worker-15,2117)
	(ForkJoinPool-1-worker-9,2947)
	(ForkJoinPool-1-worker-11,2523)
	(ForkJoinPool-1-worker-7,2381)
	(ForkJoinPool-1-worker-13,3315)
	(ForkJoinPool-1-worker-3,2085)
mailbox-size=0|execCount=0|actor state=Suspended|active count=11
_________________________________________________________________________________________________________________________________________
From source:


ThreadPoolConfig
 val corePoolSize = getIntegerProp("actors.corePoolSize") match {
     case Some(i) if i > 0 => i
     case _ => {
       val byCores = rt.availableProcessors() * 2
       if (byCores > minNumThreads) byCores else minNumThreads
     }
   }

 /** State of an actor.
   *
   *  - '''New''' -
   *      Not yet started
   *  - '''Runnable''' -
   *      Executing
   *  - '''Suspended''' -
   *      Suspended, waiting in a `react`
   *  - '''TimedSuspended''' -
   *      Suspended, waiting in a `reactWithin`
   *  - '''Blocked''' -
   *      Blocked waiting in a `receive`
   *  - '''TimedBlocked''' -
   *      Blocked waiting in a `receiveWithin`
   *  - '''Terminated''' -
   *      Actor has terminated
   */

 Questions:?
  1) map receive function?
           if(mailbox has msg matching the partial function){
                apply partial function on message and send result back
           } else {
                synch {//for a empty mailbox, the current running thread takes a lock on actor object
                    waitingFor = f
                    isSuspended = true
                    scheduler.managedBlock(blocker)
                    drainSendBuffer(mailbox)
                }
           }

  1.1) ForkJoinScheduler.managedBlock(blocker)
        /* Used for notifying scheduler when blocking inside receive/receiveWithin. */
         private object blocker extends scala.concurrent.ManagedBlocker {
           def block() = {
             InternalActor.this.suspendActor()
             true
           }
           def isReleasable =
             !InternalActor.this.isSuspended
         }

  1.2) private def suspendActor() = synchronized {
           while (isSuspended) {
             try {
               wait()  // the current thread now waits on the actor object
             } catch {
               case _: InterruptedException =>
             }
           }
           // links: check if we should exit
           if (shouldExit) exit()
         }

         private def resumeActor() {
           isSuspended = false
           notify()
         }
  1.3) Who resumes up the thread again? must be the send()
       def send(msg: Msg, replyTo: OutputChannel[Any]) {
        val todo = synchronized {
          if (waitingFor ne Reactor.waitingForNone) { // if blocked execute the last blocked operation
            val savedWaitingFor = waitingFor
            waitingFor = Reactor.waitingForNone
            startSearch(msg, replyTo, savedWaitingFor)  // the one that finally calls searchMailbox which calls notify()
          } else {
            sendBuffer.append(msg, replyTo)
            () => { /* do nothing */ }
          }
        }
        todo()
      }

  1.4) private[actors] def searchMailbox(startMbox: MQueue[Msg],
                                           handler: PartialFunction[Msg, Any],
                                           resumeOnSameThread: Boolean) {

       private[actors] override def startSearch(msg: Any, replyTo: OutputChannel[Any], handler: PartialFunction[Any, Any]) =
            if (isSuspended) {
              () =>
                synchronized {
                  mailbox.append(msg, replyTo)
                  resumeActor()
                }
       } else super.startSearch(msg, replyTo, handler)

  1.4) the start() calling act()
    // guarded by this
     private[actors] def dostart() {
       _state = Actor.State.Runnable
       scheduler newActor this
       scheduler execute makeReaction(() => {
         preAct()
         act()
       }, null, null)
     }



  2) map react function?



  3) Explain loop first with fork-join?


  4) why react with no loop wont work?




  5) how one actor can block other actors





